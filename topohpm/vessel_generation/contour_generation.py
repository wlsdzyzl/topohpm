import numpy as np
import scipy as cp
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d

# two start points, generated by gaussian distribution
def normalized(v):
    if len(v.shape) == 1:
        return v / np.sqrt(np.sum(v**2))
    else:
        return v / np.sqrt(np.sum(v**2, axis = 1))[:, None]

def row_wise_dot(n, m):
    return np.sum(n * m, axis = 1)

def rotation_matrix(f,t):
    if len(f.shape) == 1:
        dim = len(f)
        if (f == t).all():
            return np.eye(dim)
        elif (f == -t).all():
            return -np.eye(dim)
        if dim == 3:
            # print(f, t)
            v = np.cross(f, t)
            u = v/np.linalg.norm(v)
            c = np.dot(f, t)
            h = (1 - c)/(1 - c**2)
            vx, vy, vz = v
            rot =[[c + h*vx**2, h*vx*vy - vz, h*vx*vz + vy],
                [h*vx*vy+vz, c+h*vy**2, h*vy*vz-vx],
                [h*vx*vz - vy, h*vy*vz + vx, c+h*vz**2]]
            return np.array(rot)
        elif dim == 2:
            rot = [[f[0] * t[0] + f[1] * t[1], t[0] * f[1] - f[0] * t[1] ], 
                [f[0] * t[1] - t[0] * f[1], f[0] * t[0] + f[1] * t[1]]]
            return np.array(rot)
    else:
        # multiple pairs
        num, dim = f.shape
        rot = np.zeros((num, dim, dim))
        selector1 = (f == t).all(axis = 1)
        rot[selector1] = np.eye(dim)
        selector2 = (f == -t).all(axis = 1)
        rot[selector2] = - np.eye(dim)
        selector = np.logical_not(np.logical_or(selector1, selector2))
        
        if dim == 3:
            v = np.cross(f[selector], t[selector])
            u = v/np.linalg.norm(v, axis = 1)[:, None]
            c = row_wise_dot(f[selector], t[selector])
            h = (1 - c)/(1 - c**2)
            vx = v[:, 0]
            vy = v[:, 1] 
            vz = v[:, 2]
            rot[selector, 0, 0] = c + h*vx**2
            rot[selector, 0, 1] = h*vx*vy - vz
            rot[selector, 0, 2] = h*vx*vz + vy
            rot[selector, 1, 0] = h*vx*vy + vz
            rot[selector, 1, 1] = c + h*vy**2
            rot[selector, 1, 2] = h*vy*vz-vx
            rot[selector, 2, 0] = h*vx*vz - vy
            rot[selector, 2, 1] = h*vy*vz + vx
            rot[selector, 2, 2] = c + h*vz**2
            return rot
        elif dim == 2:
            rot[selector, 0, 0] = f[selector, 0] * t[selector, 0] + f[selector, 1] * t[selector, 1]
            rot[selector, 0, 1] = t[selector, 0] * f[selector, 1] - f[selector, 0] * t[selector, 1]
            rot[selector, 1, 0] = f[selector, 0] * t[selector, 1] - t[selector, 0] * f[selector, 1]
            rot[selector, 1, 1] = f[selector, 0] * t[selector, 0] + f[selector, 1] * t[selector, 1]
            return np.array(rot)
def uniform_sampling_within_acute_angle(n, angle = np.pi / 2, d = 3):

    valid_n = 0
    up = np.zeros(d)
    up[-1] = 1.0
    threshold = np.cos(angle)
    result = None
    while(valid_n < n):
        sample = np.random.randn(n - valid_n, d)
        sample[:, d - 1][sample[:, d - 1] < 0] = - sample[:, d - 1][sample[:, d - 1] < 0]
        sample = sample / np.sqrt(np.sum(sample ** 2, axis = 1))[:, None]
        cos_angle = sample @ up
        # print(cos_angle, threshold)
        print(valid_n)
        if result is None:
            result = sample[cos_angle > threshold]
        else:
            result = np.vstack((result, sample[cos_angle > threshold]))
        valid_n = len(result)
    return result
def generate_mass_points(start_p, num = 10, angle_range = np.pi / 2, len_mean = 15, len_dev = 1.5, init_direction = None):
    d = start_p.shape[0]
    mass_points = np.zeros((num + 1, d))
    mass_points[0] = start_p
    current_p = start_p
    up = np.zeros(d)
    up[-1] = 1.0

    if init_direction is None:
        init_direction = np.zeros(d)
        init_direction[-1] = -1.0
    rand_vec = uniform_sampling_within_acute_angle(num, angle = angle_range, d = d)
    print(rand_vec)
    rand_len = np.random.normal(len_mean, len_dev, num)
    for i in range(num):
        rot = rotation_matrix(up, init_direction)
        # print(rot)
        init_direction = rot @ rand_vec[i]

        current_p += init_direction * rand_len[i]
        mass_points[i+1] = current_p
    return mass_points

def cubic_spline(mass_points, num):
    n, d = mass_points.shape
    x = np.linspace(0, n, num = n, endpoint = True)
    x_new = np.linspace(0, n, num = num, endpoint = True)
    result_p = np.zeros((num, d))
    for i in range(d):
        f = interp1d(x, mass_points[:, i], kind='cubic')
        result_p[:, i] = f(x_new)
    return result_p

def generate_radius(mass_p_num, num, start_r_mean, start_r_dev, end_r_mean, end_r_dev):
    radius = [start_r_mean]
    mass_r = np.array([np.random.normal(start_r_mean + (end_r_mean - start_r_mean) * ((i + 0.0) / (mass_p_num - 1)) , start_r_dev + (end_r_dev - start_r_dev) * ((i + 0.0) / (mass_p_num - 1)), 1) for i in range(mass_p_num)])
    x = np.linspace(0, mass_p_num, num = mass_p_num, endpoint = True)
    x_new = np.linspace(0, mass_p_num, num = num, endpoint = True)
    f = interp1d(x, mass_r[:, 0])
    radius = f(x_new)
    return mass_r, radius

# mass_p = generate_mass_points(np.array([0.0, 200.0]), angle_range = np.pi / 4, num = 6, len_mean = 30)
# radius = generate_radius(6, 1000, 1, 0.1, 0.01, 0.005)
# print(radius)
# curve_p = cubic_spline(mass_p, 1000)

# plt.scatter(mass_p[:,0], mass_p[:,1])
# plt.scatter(curve_p[:,0], curve_p[:,1], s = radius * 20)
# plt.xlim(-100, 100)
# plt.ylim(0, 200)
# plt.gca().set_aspect('equal', adjustable='box')
# plt.show()

# plt.savefig('test.png')